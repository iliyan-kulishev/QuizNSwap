@model TopicCreateViewModel


@await Html.PartialAsync("_Header", Model.HeaderContainer)
@await Html.PartialAsync("_Wrapper", Model.WrapperContainer)




<script>
    //ELEMENTS
    //get the hidden li loaded from the partial view
    const hiddenQuestionCard = document.querySelector("li[data-sampleQuestionCard]");
    //get the question number span element inside
    //const span_questionNumber = hiddenQuestionCard.querySelector("span.question__number");//won't need that

    const btnAddQuestion = document.getElementById("btn_addQuestion");
    const listQuestionCards = document.getElementById("list_questionCards");
    const spanQuestionCountNum = document.getElementById("spanQuestionCountNum");
    const spanQuestionCountText = document.getElementById("spanQuestionCountText");
    let listingOrderCount = parseInt(spanQuestionCountNum.textContent, 10);//must be 0
 



    //EVENTS FOR CHANGE IN THE NUMBER OF QUESTION CARDS

    function updateQuestionCardsOrder()
    {
        //grab all cards in the list
        //number them from 1 til ...
        //what if 0 cards hmmm
        const length = listQuestionCards.children.length - 1;//again, because the add ? btn is last elem
        for (let i = 0; i < length; i++)
        {
            stampQuestionCardwNumber(listQuestionCards.children[i], i+1);
        }
    }

    function updateOrderCount(isAdd)
    {
        listingOrderCount += isAdd ? 1 : -1;
    }

    function updateQuestionsCount()
    {       
        spanQuestionCountNum.textContent = listingOrderCount;

        spanQuestionCountText.textContent = (listingOrderCount > 1 || listingOrderCount == 0) ? "questions" : "question";
    }


    //ADD QUESTION
    btnAddQuestion.addEventListener("click", addQuestionCard);


    function addQuestionCard()
    {
        const newQuestionCard = nextQuestionCard();

        const length = listQuestionCards.children.length;

        // Append the cloned element before the last element (the add question button that is)
        listQuestionCards.insertBefore(newQuestionCard, listQuestionCards.children[length - 1]);
    }

    function nextQuestionCard()
    {
        const newQuestionCard = hiddenQuestionCard.cloneNode(true);
        document.body.append(newQuestionCard);

        updateOrderCount(true);
        stampQuestionCardwNumber(newQuestionCard);

        configQuestionCardClosing(newQuestionCard);

        //unhide it
        newQuestionCard.style.display="block";

        //refresh question count
        updateQuestionsCount();

        return newQuestionCard;
    }

    function stampQuestionCardwNumber(questionCardElem, optionalNum)
    {
        const span_questionNumber = questionCardElem.querySelector("span[data-order-num]");
        span_questionNumber.textContent = optionalNum != null ? optionalNum : listingOrderCount + ".";
    }

    function configQuestionCardClosing(questionCardElem)
    {
        //get the delete Question button

        let span_deleteQuestion = questionCardElem.querySelector("span[data-delete-question]");
        //configure click handler for closing
        span_deleteQuestion.addEventListener('click', (e) => {
            span_deleteQuestion.parentNode.remove();

            //refresh numbering for cards and counter up top
            updateOrderCount(false);
            updateQuestionsCount();
            updateQuestionCardsOrder();
            });
    }












    function configQuestionCardDelete(questionCardElem)
    {
        //get the delete Question button

        let span_deleteQuestion = questionCardElem.querySelector("span[data-delete-question]");
        //configure click handler for deletion
        //...
        

    }


  








    function numberQuestionCardDown()
    {
        listing--;
        return listing;
    }


    function removeQuestionCard()
    {
    }


</script>
